-- File auto generated by purescript-bridge! --
module Language.Marlowe.ACTUS.Domain.ContractTerms where

import Prelude

import Control.Lazy (defer)
import Data.Argonaut (encodeJson, jsonNull)
import Data.Argonaut.Decode (class DecodeJson)
import Data.Argonaut.Decode.Aeson ((</$\>), (</*\>), (</\>))
import Data.Argonaut.Decode.Aeson as D
import Data.Argonaut.Encode (class EncodeJson)
import Data.Argonaut.Encode.Aeson ((>$<), (>/\<))
import Data.Argonaut.Encode.Aeson as E
import Data.BigInt.Argonaut (BigInt)
import Data.Bounded.Generic (genericBottom, genericTop)
import Data.Enum (class Enum)
import Data.Enum.Generic (genericPred, genericSucc)
import Data.Generic.Rep (class Generic)
import Data.Lens (Iso', Lens', Prism', iso, prism')
import Data.Lens.Iso.Newtype (_Newtype)
import Data.Lens.Record (prop)
import Data.Map as Map
import Data.Maybe (Maybe(..))
import Data.Newtype (class Newtype, unwrap)
import Data.Show.Generic (genericShow)
import Data.Tuple.Nested ((/\))
import Type.Proxy (Proxy(Proxy))

newtype Assertion = NpvAssertionAgainstZeroRiskBond
  { zeroRiskInterest :: Number
  , expectedNpv :: Number
  }

instance EncodeJson Assertion where
  encodeJson = defer \_ -> E.encode $ unwrap >$<
    ( E.record
        { zeroRiskInterest: E.value :: _ Number
        , expectedNpv: E.value :: _ Number
        }
    )

instance DecodeJson Assertion where
  decodeJson = defer \_ -> D.decode $
    ( NpvAssertionAgainstZeroRiskBond <$> D.record
        "NpvAssertionAgainstZeroRiskBond"
        { zeroRiskInterest: D.value :: _ Number
        , expectedNpv: D.value :: _ Number
        }
    )

derive instance Generic Assertion _

derive instance Newtype Assertion _

--------------------------------------------------------------------------------

_NpvAssertionAgainstZeroRiskBond :: Iso' Assertion
  { zeroRiskInterest :: Number, expectedNpv :: Number }
_NpvAssertionAgainstZeroRiskBond = _Newtype

--------------------------------------------------------------------------------

newtype AssertionContext = AssertionContext
  { rrmoMin :: Number
  , rrmoMax :: Number
  }

instance EncodeJson AssertionContext where
  encodeJson = defer \_ -> E.encode $ unwrap >$<
    ( E.record
        { rrmoMin: E.value :: _ Number
        , rrmoMax: E.value :: _ Number
        }
    )

instance DecodeJson AssertionContext where
  decodeJson = defer \_ -> D.decode $
    ( AssertionContext <$> D.record "AssertionContext"
        { rrmoMin: D.value :: _ Number
        , rrmoMax: D.value :: _ Number
        }
    )

derive instance Generic AssertionContext _

derive instance Newtype AssertionContext _

--------------------------------------------------------------------------------

_AssertionContext :: Iso' AssertionContext
  { rrmoMin :: Number, rrmoMax :: Number }
_AssertionContext = _Newtype

--------------------------------------------------------------------------------

newtype Assertions = Assertions
  { context :: AssertionContext
  , assertions :: Array Assertion
  }

instance EncodeJson Assertions where
  encodeJson = defer \_ -> E.encode $ unwrap >$<
    ( E.record
        { context: E.value :: _ AssertionContext
        , assertions: E.value :: _ (Array Assertion)
        }
    )

instance DecodeJson Assertions where
  decodeJson = defer \_ -> D.decode $
    ( Assertions <$> D.record "Assertions"
        { context: D.value :: _ AssertionContext
        , assertions: D.value :: _ (Array Assertion)
        }
    )

derive instance Generic Assertions _

derive instance Newtype Assertions _

--------------------------------------------------------------------------------

_Assertions :: Iso' Assertions
  { context :: AssertionContext, assertions :: Array Assertion }
_Assertions = _Newtype

--------------------------------------------------------------------------------

data BDC
  = BDC_NULL
  | BDC_SCF
  | BDC_SCMF
  | BDC_CSF
  | BDC_CSMF
  | BDC_SCP
  | BDC_SCMP
  | BDC_CSP
  | BDC_CSMP

derive instance Eq BDC

derive instance Ord BDC

instance Show BDC where
  show a = genericShow a

instance EncodeJson BDC where
  encodeJson = defer \_ -> E.encode E.enum

instance DecodeJson BDC where
  decodeJson = defer \_ -> D.decode D.enum

derive instance Generic BDC _

instance Enum BDC where
  succ = genericSucc
  pred = genericPred

instance Bounded BDC where
  bottom = genericBottom
  top = genericTop

--------------------------------------------------------------------------------

_BDC_NULL :: Prism' BDC Unit
_BDC_NULL = prism' (const BDC_NULL) case _ of
  BDC_NULL -> Just unit
  _ -> Nothing

_BDC_SCF :: Prism' BDC Unit
_BDC_SCF = prism' (const BDC_SCF) case _ of
  BDC_SCF -> Just unit
  _ -> Nothing

_BDC_SCMF :: Prism' BDC Unit
_BDC_SCMF = prism' (const BDC_SCMF) case _ of
  BDC_SCMF -> Just unit
  _ -> Nothing

_BDC_CSF :: Prism' BDC Unit
_BDC_CSF = prism' (const BDC_CSF) case _ of
  BDC_CSF -> Just unit
  _ -> Nothing

_BDC_CSMF :: Prism' BDC Unit
_BDC_CSMF = prism' (const BDC_CSMF) case _ of
  BDC_CSMF -> Just unit
  _ -> Nothing

_BDC_SCP :: Prism' BDC Unit
_BDC_SCP = prism' (const BDC_SCP) case _ of
  BDC_SCP -> Just unit
  _ -> Nothing

_BDC_SCMP :: Prism' BDC Unit
_BDC_SCMP = prism' (const BDC_SCMP) case _ of
  BDC_SCMP -> Just unit
  _ -> Nothing

_BDC_CSP :: Prism' BDC Unit
_BDC_CSP = prism' (const BDC_CSP) case _ of
  BDC_CSP -> Just unit
  _ -> Nothing

_BDC_CSMP :: Prism' BDC Unit
_BDC_CSMP = prism' (const BDC_CSMP) case _ of
  BDC_CSMP -> Just unit
  _ -> Nothing

--------------------------------------------------------------------------------

data CEGE
  = CEGE_NO
  | CEGE_NI

derive instance Eq CEGE

derive instance Ord CEGE

instance Show CEGE where
  show a = genericShow a

instance EncodeJson CEGE where
  encodeJson = defer \_ -> E.encode E.enum

instance DecodeJson CEGE where
  decodeJson = defer \_ -> D.decode D.enum

derive instance Generic CEGE _

instance Enum CEGE where
  succ = genericSucc
  pred = genericPred

instance Bounded CEGE where
  bottom = genericBottom
  top = genericTop

--------------------------------------------------------------------------------

_CEGE_NO :: Prism' CEGE Unit
_CEGE_NO = prism' (const CEGE_NO) case _ of
  CEGE_NO -> Just unit
  _ -> Nothing

_CEGE_NI :: Prism' CEGE Unit
_CEGE_NI = prism' (const CEGE_NI) case _ of
  CEGE_NI -> Just unit
  _ -> Nothing

--------------------------------------------------------------------------------

data CETC
  = CETC_DL
  | CETC_DQ
  | CETC_DF

derive instance Eq CETC

derive instance Ord CETC

instance Show CETC where
  show a = genericShow a

instance EncodeJson CETC where
  encodeJson = defer \_ -> E.encode E.enum

instance DecodeJson CETC where
  decodeJson = defer \_ -> D.decode D.enum

derive instance Generic CETC _

instance Enum CETC where
  succ = genericSucc
  pred = genericPred

instance Bounded CETC where
  bottom = genericBottom
  top = genericTop

--------------------------------------------------------------------------------

_CETC_DL :: Prism' CETC Unit
_CETC_DL = prism' (const CETC_DL) case _ of
  CETC_DL -> Just unit
  _ -> Nothing

_CETC_DQ :: Prism' CETC Unit
_CETC_DQ = prism' (const CETC_DQ) case _ of
  CETC_DQ -> Just unit
  _ -> Nothing

_CETC_DF :: Prism' CETC Unit
_CETC_DF = prism' (const CETC_DF) case _ of
  CETC_DF -> Just unit
  _ -> Nothing

--------------------------------------------------------------------------------

data CR
  = CR_RPA
  | CR_RPL
  | CR_CLO
  | CR_CNO
  | CR_COL
  | CR_LG
  | CR_ST
  | CR_BUY
  | CR_SEL
  | CR_RFL
  | CR_PFL
  | CR_RF
  | CR_PF

derive instance Eq CR

derive instance Ord CR

instance Show CR where
  show a = genericShow a

instance EncodeJson CR where
  encodeJson = defer \_ -> E.encode E.enum

instance DecodeJson CR where
  decodeJson = defer \_ -> D.decode D.enum

derive instance Generic CR _

instance Enum CR where
  succ = genericSucc
  pred = genericPred

instance Bounded CR where
  bottom = genericBottom
  top = genericTop

--------------------------------------------------------------------------------

_CR_RPA :: Prism' CR Unit
_CR_RPA = prism' (const CR_RPA) case _ of
  CR_RPA -> Just unit
  _ -> Nothing

_CR_RPL :: Prism' CR Unit
_CR_RPL = prism' (const CR_RPL) case _ of
  CR_RPL -> Just unit
  _ -> Nothing

_CR_CLO :: Prism' CR Unit
_CR_CLO = prism' (const CR_CLO) case _ of
  CR_CLO -> Just unit
  _ -> Nothing

_CR_CNO :: Prism' CR Unit
_CR_CNO = prism' (const CR_CNO) case _ of
  CR_CNO -> Just unit
  _ -> Nothing

_CR_COL :: Prism' CR Unit
_CR_COL = prism' (const CR_COL) case _ of
  CR_COL -> Just unit
  _ -> Nothing

_CR_LG :: Prism' CR Unit
_CR_LG = prism' (const CR_LG) case _ of
  CR_LG -> Just unit
  _ -> Nothing

_CR_ST :: Prism' CR Unit
_CR_ST = prism' (const CR_ST) case _ of
  CR_ST -> Just unit
  _ -> Nothing

_CR_BUY :: Prism' CR Unit
_CR_BUY = prism' (const CR_BUY) case _ of
  CR_BUY -> Just unit
  _ -> Nothing

_CR_SEL :: Prism' CR Unit
_CR_SEL = prism' (const CR_SEL) case _ of
  CR_SEL -> Just unit
  _ -> Nothing

_CR_RFL :: Prism' CR Unit
_CR_RFL = prism' (const CR_RFL) case _ of
  CR_RFL -> Just unit
  _ -> Nothing

_CR_PFL :: Prism' CR Unit
_CR_PFL = prism' (const CR_PFL) case _ of
  CR_PFL -> Just unit
  _ -> Nothing

_CR_RF :: Prism' CR Unit
_CR_RF = prism' (const CR_RF) case _ of
  CR_RF -> Just unit
  _ -> Nothing

_CR_PF :: Prism' CR Unit
_CR_PF = prism' (const CR_PF) case _ of
  CR_PF -> Just unit
  _ -> Nothing

--------------------------------------------------------------------------------

data CT
  = PAM
  | LAM
  | NAM
  | ANN
  | STK
  | OPTNS
  | FUTUR
  | COM
  | CSH
  | CLM
  | SWPPV
  | CEG
  | CEC

derive instance Eq CT

derive instance Ord CT

instance Show CT where
  show a = genericShow a

instance EncodeJson CT where
  encodeJson = defer \_ -> E.encode E.enum

instance DecodeJson CT where
  decodeJson = defer \_ -> D.decode D.enum

derive instance Generic CT _

instance Enum CT where
  succ = genericSucc
  pred = genericPred

instance Bounded CT where
  bottom = genericBottom
  top = genericTop

--------------------------------------------------------------------------------

_PAM :: Prism' CT Unit
_PAM = prism' (const PAM) case _ of
  PAM -> Just unit
  _ -> Nothing

_LAM :: Prism' CT Unit
_LAM = prism' (const LAM) case _ of
  LAM -> Just unit
  _ -> Nothing

_NAM :: Prism' CT Unit
_NAM = prism' (const NAM) case _ of
  NAM -> Just unit
  _ -> Nothing

_ANN :: Prism' CT Unit
_ANN = prism' (const ANN) case _ of
  ANN -> Just unit
  _ -> Nothing

_STK :: Prism' CT Unit
_STK = prism' (const STK) case _ of
  STK -> Just unit
  _ -> Nothing

_OPTNS :: Prism' CT Unit
_OPTNS = prism' (const OPTNS) case _ of
  OPTNS -> Just unit
  _ -> Nothing

_FUTUR :: Prism' CT Unit
_FUTUR = prism' (const FUTUR) case _ of
  FUTUR -> Just unit
  _ -> Nothing

_COM :: Prism' CT Unit
_COM = prism' (const COM) case _ of
  COM -> Just unit
  _ -> Nothing

_CSH :: Prism' CT Unit
_CSH = prism' (const CSH) case _ of
  CSH -> Just unit
  _ -> Nothing

_CLM :: Prism' CT Unit
_CLM = prism' (const CLM) case _ of
  CLM -> Just unit
  _ -> Nothing

_SWPPV :: Prism' CT Unit
_SWPPV = prism' (const SWPPV) case _ of
  SWPPV -> Just unit
  _ -> Nothing

_CEG :: Prism' CT Unit
_CEG = prism' (const CEG) case _ of
  CEG -> Just unit
  _ -> Nothing

_CEC :: Prism' CT Unit
_CEC = prism' (const CEC) case _ of
  CEC -> Just unit
  _ -> Nothing

--------------------------------------------------------------------------------

data Calendar
  = CLDR_MF
  | CLDR_NC

derive instance Eq Calendar

derive instance Ord Calendar

instance Show Calendar where
  show a = genericShow a

instance EncodeJson Calendar where
  encodeJson = defer \_ -> E.encode E.enum

instance DecodeJson Calendar where
  decodeJson = defer \_ -> D.decode D.enum

derive instance Generic Calendar _

instance Enum Calendar where
  succ = genericSucc
  pred = genericPred

instance Bounded Calendar where
  bottom = genericBottom
  top = genericTop

--------------------------------------------------------------------------------

_CLDR_MF :: Prism' Calendar Unit
_CLDR_MF = prism' (const CLDR_MF) case _ of
  CLDR_MF -> Just unit
  _ -> Nothing

_CLDR_NC :: Prism' Calendar Unit
_CLDR_NC = prism' (const CLDR_NC) case _ of
  CLDR_NC -> Just unit
  _ -> Nothing

--------------------------------------------------------------------------------

newtype ContractStructure a = ContractStructure
  { reference :: Reference a
  , referenceType :: ReferenceType
  , referenceRole :: ReferenceRole
  }

instance (EncodeJson a) => EncodeJson (ContractStructure a) where
  encodeJson = defer \_ -> E.encode $ unwrap >$<
    ( E.record
        { reference: E.value :: _ (Reference a)
        , referenceType: E.value :: _ ReferenceType
        , referenceRole: E.value :: _ ReferenceRole
        }
    )

instance (DecodeJson a) => DecodeJson (ContractStructure a) where
  decodeJson = defer \_ -> D.decode $
    ( ContractStructure <$> D.record "ContractStructure"
        { reference: D.value :: _ (Reference a)
        , referenceType: D.value :: _ ReferenceType
        , referenceRole: D.value :: _ ReferenceRole
        }
    )

derive instance Generic (ContractStructure a) _

derive instance Newtype (ContractStructure a) _

--------------------------------------------------------------------------------

_ContractStructure
  :: forall a
   . Iso' (ContractStructure a)
       { reference :: Reference a
       , referenceType :: ReferenceType
       , referenceRole :: ReferenceRole
       }
_ContractStructure = _Newtype

--------------------------------------------------------------------------------

newtype ContractTermsPoly a = ContractTermsPoly
  { contractId :: String
  , contractType :: CT
  , contractStructure :: Array (ContractStructure a)
  , contractRole :: CR
  , settlementCurrency :: Maybe String
  , initialExchangeDate :: Maybe String
  , dayCountConvention :: Maybe DCC
  , scheduleConfig :: ScheduleConfig
  , statusDate :: String
  , contractPerformance :: Maybe PRF
  , creditEventTypeCovered :: Maybe CETC
  , coverageOfCreditEnhancement :: Maybe a
  , guaranteedExposure :: Maybe CEGE
  , cycleOfFee :: Maybe Cycle
  , cycleAnchorDateOfFee :: Maybe String
  , feeAccrued :: Maybe a
  , feeBasis :: Maybe FEB
  , feeRate :: Maybe a
  , cycleAnchorDateOfInterestPayment :: Maybe String
  , cycleOfInterestPayment :: Maybe Cycle
  , accruedInterest :: Maybe a
  , capitalizationEndDate :: Maybe String
  , cycleAnchorDateOfInterestCalculationBase :: Maybe String
  , cycleOfInterestCalculationBase :: Maybe Cycle
  , interestCalculationBase :: Maybe IPCB
  , interestCalculationBaseA :: Maybe a
  , nominalInterestRate :: Maybe a
  , nominalInterestRate2 :: Maybe a
  , interestScalingMultiplier :: Maybe a
  , maturityDate :: Maybe String
  , amortizationDate :: Maybe String
  , exerciseDate :: Maybe String
  , notionalPrincipal :: Maybe a
  , premiumDiscountAtIED :: Maybe a
  , cycleAnchorDateOfPrincipalRedemption :: Maybe String
  , cycleOfPrincipalRedemption :: Maybe Cycle
  , nextPrincipalRedemptionPayment :: Maybe a
  , purchaseDate :: Maybe String
  , priceAtPurchaseDate :: Maybe a
  , terminationDate :: Maybe String
  , priceAtTerminationDate :: Maybe a
  , quantity :: Maybe a
  , scalingIndexAtStatusDate :: Maybe a
  , cycleAnchorDateOfScalingIndex :: Maybe String
  , cycleOfScalingIndex :: Maybe Cycle
  , scalingEffect :: Maybe SCEF
  , scalingIndexAtContractDealDate :: Maybe a
  , marketObjectCodeOfScalingIndex :: Maybe String
  , notionalScalingMultiplier :: Maybe a
  , cycleOfOptionality :: Maybe Cycle
  , cycleAnchorDateOfOptionality :: Maybe String
  , optionType :: Maybe OPTP
  , optionStrike1 :: Maybe a
  , optionExerciseType :: Maybe OPXT
  , settlementPeriod :: Maybe Cycle
  , deliverySettlement :: Maybe DS
  , exerciseAmount :: Maybe a
  , futuresPrice :: Maybe a
  , penaltyRate :: Maybe a
  , penaltyType :: Maybe PYTP
  , prepaymentEffect :: Maybe PPEF
  , cycleOfRateReset :: Maybe Cycle
  , cycleAnchorDateOfRateReset :: Maybe String
  , nextResetRate :: Maybe a
  , rateSpread :: Maybe a
  , rateMultiplier :: Maybe a
  , periodFloor :: Maybe a
  , periodCap :: Maybe a
  , lifeCap :: Maybe a
  , lifeFloor :: Maybe a
  , marketObjectCodeOfRateReset :: Maybe String
  , cycleOfDividend :: Maybe Cycle
  , cycleAnchorDateOfDividend :: Maybe String
  , nextDividendPaymentAmount :: Maybe a
  , enableSettlement :: Boolean
  , constraints :: Maybe Assertions
  }

instance (EncodeJson a) => EncodeJson (ContractTermsPoly a) where
  encodeJson = defer \_ -> E.encode $ unwrap >$<
    ( E.record
        { contractId: E.value :: _ String
        , contractType: E.value :: _ CT
        , contractStructure: E.value :: _ (Array (ContractStructure a))
        , contractRole: E.value :: _ CR
        , settlementCurrency: (E.maybe E.value) :: _ (Maybe String)
        , initialExchangeDate: (E.maybe E.value) :: _ (Maybe String)
        , dayCountConvention: (E.maybe E.value) :: _ (Maybe DCC)
        , scheduleConfig: E.value :: _ ScheduleConfig
        , statusDate: E.value :: _ String
        , contractPerformance: (E.maybe E.value) :: _ (Maybe PRF)
        , creditEventTypeCovered: (E.maybe E.value) :: _ (Maybe CETC)
        , coverageOfCreditEnhancement: (E.maybe E.value) :: _ (Maybe a)
        , guaranteedExposure: (E.maybe E.value) :: _ (Maybe CEGE)
        , cycleOfFee: (E.maybe E.value) :: _ (Maybe Cycle)
        , cycleAnchorDateOfFee: (E.maybe E.value) :: _ (Maybe String)
        , feeAccrued: (E.maybe E.value) :: _ (Maybe a)
        , feeBasis: (E.maybe E.value) :: _ (Maybe FEB)
        , feeRate: (E.maybe E.value) :: _ (Maybe a)
        , cycleAnchorDateOfInterestPayment:
            (E.maybe E.value) :: _ (Maybe String)
        , cycleOfInterestPayment: (E.maybe E.value) :: _ (Maybe Cycle)
        , accruedInterest: (E.maybe E.value) :: _ (Maybe a)
        , capitalizationEndDate: (E.maybe E.value) :: _ (Maybe String)
        , cycleAnchorDateOfInterestCalculationBase:
            (E.maybe E.value) :: _ (Maybe String)
        , cycleOfInterestCalculationBase: (E.maybe E.value) :: _ (Maybe Cycle)
        , interestCalculationBase: (E.maybe E.value) :: _ (Maybe IPCB)
        , interestCalculationBaseA: (E.maybe E.value) :: _ (Maybe a)
        , nominalInterestRate: (E.maybe E.value) :: _ (Maybe a)
        , nominalInterestRate2: (E.maybe E.value) :: _ (Maybe a)
        , interestScalingMultiplier: (E.maybe E.value) :: _ (Maybe a)
        , maturityDate: (E.maybe E.value) :: _ (Maybe String)
        , amortizationDate: (E.maybe E.value) :: _ (Maybe String)
        , exerciseDate: (E.maybe E.value) :: _ (Maybe String)
        , notionalPrincipal: (E.maybe E.value) :: _ (Maybe a)
        , premiumDiscountAtIED: (E.maybe E.value) :: _ (Maybe a)
        , cycleAnchorDateOfPrincipalRedemption:
            (E.maybe E.value) :: _ (Maybe String)
        , cycleOfPrincipalRedemption: (E.maybe E.value) :: _ (Maybe Cycle)
        , nextPrincipalRedemptionPayment: (E.maybe E.value) :: _ (Maybe a)
        , purchaseDate: (E.maybe E.value) :: _ (Maybe String)
        , priceAtPurchaseDate: (E.maybe E.value) :: _ (Maybe a)
        , terminationDate: (E.maybe E.value) :: _ (Maybe String)
        , priceAtTerminationDate: (E.maybe E.value) :: _ (Maybe a)
        , quantity: (E.maybe E.value) :: _ (Maybe a)
        , scalingIndexAtStatusDate: (E.maybe E.value) :: _ (Maybe a)
        , cycleAnchorDateOfScalingIndex: (E.maybe E.value) :: _ (Maybe String)
        , cycleOfScalingIndex: (E.maybe E.value) :: _ (Maybe Cycle)
        , scalingEffect: (E.maybe E.value) :: _ (Maybe SCEF)
        , scalingIndexAtContractDealDate: (E.maybe E.value) :: _ (Maybe a)
        , marketObjectCodeOfScalingIndex: (E.maybe E.value) :: _ (Maybe String)
        , notionalScalingMultiplier: (E.maybe E.value) :: _ (Maybe a)
        , cycleOfOptionality: (E.maybe E.value) :: _ (Maybe Cycle)
        , cycleAnchorDateOfOptionality: (E.maybe E.value) :: _ (Maybe String)
        , optionType: (E.maybe E.value) :: _ (Maybe OPTP)
        , optionStrike1: (E.maybe E.value) :: _ (Maybe a)
        , optionExerciseType: (E.maybe E.value) :: _ (Maybe OPXT)
        , settlementPeriod: (E.maybe E.value) :: _ (Maybe Cycle)
        , deliverySettlement: (E.maybe E.value) :: _ (Maybe DS)
        , exerciseAmount: (E.maybe E.value) :: _ (Maybe a)
        , futuresPrice: (E.maybe E.value) :: _ (Maybe a)
        , penaltyRate: (E.maybe E.value) :: _ (Maybe a)
        , penaltyType: (E.maybe E.value) :: _ (Maybe PYTP)
        , prepaymentEffect: (E.maybe E.value) :: _ (Maybe PPEF)
        , cycleOfRateReset: (E.maybe E.value) :: _ (Maybe Cycle)
        , cycleAnchorDateOfRateReset: (E.maybe E.value) :: _ (Maybe String)
        , nextResetRate: (E.maybe E.value) :: _ (Maybe a)
        , rateSpread: (E.maybe E.value) :: _ (Maybe a)
        , rateMultiplier: (E.maybe E.value) :: _ (Maybe a)
        , periodFloor: (E.maybe E.value) :: _ (Maybe a)
        , periodCap: (E.maybe E.value) :: _ (Maybe a)
        , lifeCap: (E.maybe E.value) :: _ (Maybe a)
        , lifeFloor: (E.maybe E.value) :: _ (Maybe a)
        , marketObjectCodeOfRateReset: (E.maybe E.value) :: _ (Maybe String)
        , cycleOfDividend: (E.maybe E.value) :: _ (Maybe Cycle)
        , cycleAnchorDateOfDividend: (E.maybe E.value) :: _ (Maybe String)
        , nextDividendPaymentAmount: (E.maybe E.value) :: _ (Maybe a)
        , enableSettlement: E.value :: _ Boolean
        , constraints: (E.maybe E.value) :: _ (Maybe Assertions)
        }
    )

instance (DecodeJson a) => DecodeJson (ContractTermsPoly a) where
  decodeJson = defer \_ -> D.decode $
    ( ContractTermsPoly <$> D.record "ContractTermsPoly"
        { contractId: D.value :: _ String
        , contractType: D.value :: _ CT
        , contractStructure: D.value :: _ (Array (ContractStructure a))
        , contractRole: D.value :: _ CR
        , settlementCurrency: (D.maybe D.value) :: _ (Maybe String)
        , initialExchangeDate: (D.maybe D.value) :: _ (Maybe String)
        , dayCountConvention: (D.maybe D.value) :: _ (Maybe DCC)
        , scheduleConfig: D.value :: _ ScheduleConfig
        , statusDate: D.value :: _ String
        , contractPerformance: (D.maybe D.value) :: _ (Maybe PRF)
        , creditEventTypeCovered: (D.maybe D.value) :: _ (Maybe CETC)
        , coverageOfCreditEnhancement: (D.maybe D.value) :: _ (Maybe a)
        , guaranteedExposure: (D.maybe D.value) :: _ (Maybe CEGE)
        , cycleOfFee: (D.maybe D.value) :: _ (Maybe Cycle)
        , cycleAnchorDateOfFee: (D.maybe D.value) :: _ (Maybe String)
        , feeAccrued: (D.maybe D.value) :: _ (Maybe a)
        , feeBasis: (D.maybe D.value) :: _ (Maybe FEB)
        , feeRate: (D.maybe D.value) :: _ (Maybe a)
        , cycleAnchorDateOfInterestPayment:
            (D.maybe D.value) :: _ (Maybe String)
        , cycleOfInterestPayment: (D.maybe D.value) :: _ (Maybe Cycle)
        , accruedInterest: (D.maybe D.value) :: _ (Maybe a)
        , capitalizationEndDate: (D.maybe D.value) :: _ (Maybe String)
        , cycleAnchorDateOfInterestCalculationBase:
            (D.maybe D.value) :: _ (Maybe String)
        , cycleOfInterestCalculationBase: (D.maybe D.value) :: _ (Maybe Cycle)
        , interestCalculationBase: (D.maybe D.value) :: _ (Maybe IPCB)
        , interestCalculationBaseA: (D.maybe D.value) :: _ (Maybe a)
        , nominalInterestRate: (D.maybe D.value) :: _ (Maybe a)
        , nominalInterestRate2: (D.maybe D.value) :: _ (Maybe a)
        , interestScalingMultiplier: (D.maybe D.value) :: _ (Maybe a)
        , maturityDate: (D.maybe D.value) :: _ (Maybe String)
        , amortizationDate: (D.maybe D.value) :: _ (Maybe String)
        , exerciseDate: (D.maybe D.value) :: _ (Maybe String)
        , notionalPrincipal: (D.maybe D.value) :: _ (Maybe a)
        , premiumDiscountAtIED: (D.maybe D.value) :: _ (Maybe a)
        , cycleAnchorDateOfPrincipalRedemption:
            (D.maybe D.value) :: _ (Maybe String)
        , cycleOfPrincipalRedemption: (D.maybe D.value) :: _ (Maybe Cycle)
        , nextPrincipalRedemptionPayment: (D.maybe D.value) :: _ (Maybe a)
        , purchaseDate: (D.maybe D.value) :: _ (Maybe String)
        , priceAtPurchaseDate: (D.maybe D.value) :: _ (Maybe a)
        , terminationDate: (D.maybe D.value) :: _ (Maybe String)
        , priceAtTerminationDate: (D.maybe D.value) :: _ (Maybe a)
        , quantity: (D.maybe D.value) :: _ (Maybe a)
        , scalingIndexAtStatusDate: (D.maybe D.value) :: _ (Maybe a)
        , cycleAnchorDateOfScalingIndex: (D.maybe D.value) :: _ (Maybe String)
        , cycleOfScalingIndex: (D.maybe D.value) :: _ (Maybe Cycle)
        , scalingEffect: (D.maybe D.value) :: _ (Maybe SCEF)
        , scalingIndexAtContractDealDate: (D.maybe D.value) :: _ (Maybe a)
        , marketObjectCodeOfScalingIndex: (D.maybe D.value) :: _ (Maybe String)
        , notionalScalingMultiplier: (D.maybe D.value) :: _ (Maybe a)
        , cycleOfOptionality: (D.maybe D.value) :: _ (Maybe Cycle)
        , cycleAnchorDateOfOptionality: (D.maybe D.value) :: _ (Maybe String)
        , optionType: (D.maybe D.value) :: _ (Maybe OPTP)
        , optionStrike1: (D.maybe D.value) :: _ (Maybe a)
        , optionExerciseType: (D.maybe D.value) :: _ (Maybe OPXT)
        , settlementPeriod: (D.maybe D.value) :: _ (Maybe Cycle)
        , deliverySettlement: (D.maybe D.value) :: _ (Maybe DS)
        , exerciseAmount: (D.maybe D.value) :: _ (Maybe a)
        , futuresPrice: (D.maybe D.value) :: _ (Maybe a)
        , penaltyRate: (D.maybe D.value) :: _ (Maybe a)
        , penaltyType: (D.maybe D.value) :: _ (Maybe PYTP)
        , prepaymentEffect: (D.maybe D.value) :: _ (Maybe PPEF)
        , cycleOfRateReset: (D.maybe D.value) :: _ (Maybe Cycle)
        , cycleAnchorDateOfRateReset: (D.maybe D.value) :: _ (Maybe String)
        , nextResetRate: (D.maybe D.value) :: _ (Maybe a)
        , rateSpread: (D.maybe D.value) :: _ (Maybe a)
        , rateMultiplier: (D.maybe D.value) :: _ (Maybe a)
        , periodFloor: (D.maybe D.value) :: _ (Maybe a)
        , periodCap: (D.maybe D.value) :: _ (Maybe a)
        , lifeCap: (D.maybe D.value) :: _ (Maybe a)
        , lifeFloor: (D.maybe D.value) :: _ (Maybe a)
        , marketObjectCodeOfRateReset: (D.maybe D.value) :: _ (Maybe String)
        , cycleOfDividend: (D.maybe D.value) :: _ (Maybe Cycle)
        , cycleAnchorDateOfDividend: (D.maybe D.value) :: _ (Maybe String)
        , nextDividendPaymentAmount: (D.maybe D.value) :: _ (Maybe a)
        , enableSettlement: D.value :: _ Boolean
        , constraints: (D.maybe D.value) :: _ (Maybe Assertions)
        }
    )

derive instance Generic (ContractTermsPoly a) _

derive instance Newtype (ContractTermsPoly a) _

--------------------------------------------------------------------------------

_ContractTermsPoly
  :: forall a
   . Iso' (ContractTermsPoly a)
       { contractId :: String
       , contractType :: CT
       , contractStructure :: Array (ContractStructure a)
       , contractRole :: CR
       , settlementCurrency :: Maybe String
       , initialExchangeDate :: Maybe String
       , dayCountConvention :: Maybe DCC
       , scheduleConfig :: ScheduleConfig
       , statusDate :: String
       , contractPerformance :: Maybe PRF
       , creditEventTypeCovered :: Maybe CETC
       , coverageOfCreditEnhancement :: Maybe a
       , guaranteedExposure :: Maybe CEGE
       , cycleOfFee :: Maybe Cycle
       , cycleAnchorDateOfFee :: Maybe String
       , feeAccrued :: Maybe a
       , feeBasis :: Maybe FEB
       , feeRate :: Maybe a
       , cycleAnchorDateOfInterestPayment :: Maybe String
       , cycleOfInterestPayment :: Maybe Cycle
       , accruedInterest :: Maybe a
       , capitalizationEndDate :: Maybe String
       , cycleAnchorDateOfInterestCalculationBase :: Maybe String
       , cycleOfInterestCalculationBase :: Maybe Cycle
       , interestCalculationBase :: Maybe IPCB
       , interestCalculationBaseA :: Maybe a
       , nominalInterestRate :: Maybe a
       , nominalInterestRate2 :: Maybe a
       , interestScalingMultiplier :: Maybe a
       , maturityDate :: Maybe String
       , amortizationDate :: Maybe String
       , exerciseDate :: Maybe String
       , notionalPrincipal :: Maybe a
       , premiumDiscountAtIED :: Maybe a
       , cycleAnchorDateOfPrincipalRedemption :: Maybe String
       , cycleOfPrincipalRedemption :: Maybe Cycle
       , nextPrincipalRedemptionPayment :: Maybe a
       , purchaseDate :: Maybe String
       , priceAtPurchaseDate :: Maybe a
       , terminationDate :: Maybe String
       , priceAtTerminationDate :: Maybe a
       , quantity :: Maybe a
       , scalingIndexAtStatusDate :: Maybe a
       , cycleAnchorDateOfScalingIndex :: Maybe String
       , cycleOfScalingIndex :: Maybe Cycle
       , scalingEffect :: Maybe SCEF
       , scalingIndexAtContractDealDate :: Maybe a
       , marketObjectCodeOfScalingIndex :: Maybe String
       , notionalScalingMultiplier :: Maybe a
       , cycleOfOptionality :: Maybe Cycle
       , cycleAnchorDateOfOptionality :: Maybe String
       , optionType :: Maybe OPTP
       , optionStrike1 :: Maybe a
       , optionExerciseType :: Maybe OPXT
       , settlementPeriod :: Maybe Cycle
       , deliverySettlement :: Maybe DS
       , exerciseAmount :: Maybe a
       , futuresPrice :: Maybe a
       , penaltyRate :: Maybe a
       , penaltyType :: Maybe PYTP
       , prepaymentEffect :: Maybe PPEF
       , cycleOfRateReset :: Maybe Cycle
       , cycleAnchorDateOfRateReset :: Maybe String
       , nextResetRate :: Maybe a
       , rateSpread :: Maybe a
       , rateMultiplier :: Maybe a
       , periodFloor :: Maybe a
       , periodCap :: Maybe a
       , lifeCap :: Maybe a
       , lifeFloor :: Maybe a
       , marketObjectCodeOfRateReset :: Maybe String
       , cycleOfDividend :: Maybe Cycle
       , cycleAnchorDateOfDividend :: Maybe String
       , nextDividendPaymentAmount :: Maybe a
       , enableSettlement :: Boolean
       , constraints :: Maybe Assertions
       }
_ContractTermsPoly = _Newtype

--------------------------------------------------------------------------------

newtype Cycle = Cycle
  { n :: BigInt
  , p :: Period
  , stub :: Stub
  , includeEndDay :: Boolean
  }

instance EncodeJson Cycle where
  encodeJson = defer \_ -> E.encode $ unwrap >$<
    ( E.record
        { n: E.value :: _ BigInt
        , p: E.value :: _ Period
        , stub: E.value :: _ Stub
        , includeEndDay: E.value :: _ Boolean
        }
    )

instance DecodeJson Cycle where
  decodeJson = defer \_ -> D.decode $
    ( Cycle <$> D.record "Cycle"
        { n: D.value :: _ BigInt
        , p: D.value :: _ Period
        , stub: D.value :: _ Stub
        , includeEndDay: D.value :: _ Boolean
        }
    )

derive instance Generic Cycle _

derive instance Newtype Cycle _

--------------------------------------------------------------------------------

_Cycle :: Iso' Cycle
  { n :: BigInt, p :: Period, stub :: Stub, includeEndDay :: Boolean }
_Cycle = _Newtype

--------------------------------------------------------------------------------

data DCC
  = DCC_A_AISDA
  | DCC_A_360
  | DCC_A_365
  | DCC_E30_360ISDA
  | DCC_E30_360
  | DCC_B_252

derive instance Eq DCC

derive instance Ord DCC

instance Show DCC where
  show a = genericShow a

instance EncodeJson DCC where
  encodeJson = defer \_ -> E.encode E.enum

instance DecodeJson DCC where
  decodeJson = defer \_ -> D.decode D.enum

derive instance Generic DCC _

instance Enum DCC where
  succ = genericSucc
  pred = genericPred

instance Bounded DCC where
  bottom = genericBottom
  top = genericTop

--------------------------------------------------------------------------------

_DCC_A_AISDA :: Prism' DCC Unit
_DCC_A_AISDA = prism' (const DCC_A_AISDA) case _ of
  DCC_A_AISDA -> Just unit
  _ -> Nothing

_DCC_A_360 :: Prism' DCC Unit
_DCC_A_360 = prism' (const DCC_A_360) case _ of
  DCC_A_360 -> Just unit
  _ -> Nothing

_DCC_A_365 :: Prism' DCC Unit
_DCC_A_365 = prism' (const DCC_A_365) case _ of
  DCC_A_365 -> Just unit
  _ -> Nothing

_DCC_E30_360ISDA :: Prism' DCC Unit
_DCC_E30_360ISDA = prism' (const DCC_E30_360ISDA) case _ of
  DCC_E30_360ISDA -> Just unit
  _ -> Nothing

_DCC_E30_360 :: Prism' DCC Unit
_DCC_E30_360 = prism' (const DCC_E30_360) case _ of
  DCC_E30_360 -> Just unit
  _ -> Nothing

_DCC_B_252 :: Prism' DCC Unit
_DCC_B_252 = prism' (const DCC_B_252) case _ of
  DCC_B_252 -> Just unit
  _ -> Nothing

--------------------------------------------------------------------------------

data DS
  = DS_S
  | DS_D

derive instance Eq DS

derive instance Ord DS

instance Show DS where
  show a = genericShow a

instance EncodeJson DS where
  encodeJson = defer \_ -> E.encode E.enum

instance DecodeJson DS where
  decodeJson = defer \_ -> D.decode D.enum

derive instance Generic DS _

instance Enum DS where
  succ = genericSucc
  pred = genericPred

instance Bounded DS where
  bottom = genericBottom
  top = genericTop

--------------------------------------------------------------------------------

_DS_S :: Prism' DS Unit
_DS_S = prism' (const DS_S) case _ of
  DS_S -> Just unit
  _ -> Nothing

_DS_D :: Prism' DS Unit
_DS_D = prism' (const DS_D) case _ of
  DS_D -> Just unit
  _ -> Nothing

--------------------------------------------------------------------------------

data EOMC
  = EOMC_EOM
  | EOMC_SD

derive instance Eq EOMC

derive instance Ord EOMC

instance Show EOMC where
  show a = genericShow a

instance EncodeJson EOMC where
  encodeJson = defer \_ -> E.encode E.enum

instance DecodeJson EOMC where
  decodeJson = defer \_ -> D.decode D.enum

derive instance Generic EOMC _

instance Enum EOMC where
  succ = genericSucc
  pred = genericPred

instance Bounded EOMC where
  bottom = genericBottom
  top = genericTop

--------------------------------------------------------------------------------

_EOMC_EOM :: Prism' EOMC Unit
_EOMC_EOM = prism' (const EOMC_EOM) case _ of
  EOMC_EOM -> Just unit
  _ -> Nothing

_EOMC_SD :: Prism' EOMC Unit
_EOMC_SD = prism' (const EOMC_SD) case _ of
  EOMC_SD -> Just unit
  _ -> Nothing

--------------------------------------------------------------------------------

data FEB
  = FEB_A
  | FEB_N

derive instance Eq FEB

derive instance Ord FEB

instance Show FEB where
  show a = genericShow a

instance EncodeJson FEB where
  encodeJson = defer \_ -> E.encode E.enum

instance DecodeJson FEB where
  decodeJson = defer \_ -> D.decode D.enum

derive instance Generic FEB _

instance Enum FEB where
  succ = genericSucc
  pred = genericPred

instance Bounded FEB where
  bottom = genericBottom
  top = genericTop

--------------------------------------------------------------------------------

_FEB_A :: Prism' FEB Unit
_FEB_A = prism' (const FEB_A) case _ of
  FEB_A -> Just unit
  _ -> Nothing

_FEB_N :: Prism' FEB Unit
_FEB_N = prism' (const FEB_N) case _ of
  FEB_N -> Just unit
  _ -> Nothing

--------------------------------------------------------------------------------

data IPCB
  = IPCB_NT
  | IPCB_NTIED
  | IPCB_NTL

derive instance Eq IPCB

derive instance Ord IPCB

instance Show IPCB where
  show a = genericShow a

instance EncodeJson IPCB where
  encodeJson = defer \_ -> E.encode E.enum

instance DecodeJson IPCB where
  decodeJson = defer \_ -> D.decode D.enum

derive instance Generic IPCB _

instance Enum IPCB where
  succ = genericSucc
  pred = genericPred

instance Bounded IPCB where
  bottom = genericBottom
  top = genericTop

--------------------------------------------------------------------------------

_IPCB_NT :: Prism' IPCB Unit
_IPCB_NT = prism' (const IPCB_NT) case _ of
  IPCB_NT -> Just unit
  _ -> Nothing

_IPCB_NTIED :: Prism' IPCB Unit
_IPCB_NTIED = prism' (const IPCB_NTIED) case _ of
  IPCB_NTIED -> Just unit
  _ -> Nothing

_IPCB_NTL :: Prism' IPCB Unit
_IPCB_NTL = prism' (const IPCB_NTL) case _ of
  IPCB_NTL -> Just unit
  _ -> Nothing

--------------------------------------------------------------------------------

newtype Identifier = Identifier
  { marketObjectCode :: Maybe String
  , contractIdentifier :: Maybe String
  }

derive instance Eq Identifier

derive instance Ord Identifier

instance Show Identifier where
  show a = genericShow a

instance EncodeJson Identifier where
  encodeJson = defer \_ -> E.encode $ unwrap >$<
    ( E.record
        { marketObjectCode: (E.maybe E.value) :: _ (Maybe String)
        , contractIdentifier: (E.maybe E.value) :: _ (Maybe String)
        }
    )

instance DecodeJson Identifier where
  decodeJson = defer \_ -> D.decode $
    ( Identifier <$> D.record "Identifier"
        { marketObjectCode: (D.maybe D.value) :: _ (Maybe String)
        , contractIdentifier: (D.maybe D.value) :: _ (Maybe String)
        }
    )

derive instance Generic Identifier _

derive instance Newtype Identifier _

--------------------------------------------------------------------------------

_Identifier :: Iso' Identifier
  { marketObjectCode :: Maybe String, contractIdentifier :: Maybe String }
_Identifier = _Newtype

--------------------------------------------------------------------------------

data OPTP
  = OPTP_C
  | OPTP_P
  | OPTP_CP

derive instance Eq OPTP

derive instance Ord OPTP

instance Show OPTP where
  show a = genericShow a

instance EncodeJson OPTP where
  encodeJson = defer \_ -> E.encode E.enum

instance DecodeJson OPTP where
  decodeJson = defer \_ -> D.decode D.enum

derive instance Generic OPTP _

instance Enum OPTP where
  succ = genericSucc
  pred = genericPred

instance Bounded OPTP where
  bottom = genericBottom
  top = genericTop

--------------------------------------------------------------------------------

_OPTP_C :: Prism' OPTP Unit
_OPTP_C = prism' (const OPTP_C) case _ of
  OPTP_C -> Just unit
  _ -> Nothing

_OPTP_P :: Prism' OPTP Unit
_OPTP_P = prism' (const OPTP_P) case _ of
  OPTP_P -> Just unit
  _ -> Nothing

_OPTP_CP :: Prism' OPTP Unit
_OPTP_CP = prism' (const OPTP_CP) case _ of
  OPTP_CP -> Just unit
  _ -> Nothing

--------------------------------------------------------------------------------

data OPXT
  = OPXT_E
  | OPXT_B
  | OPXT_A

derive instance Eq OPXT

derive instance Ord OPXT

instance Show OPXT where
  show a = genericShow a

instance EncodeJson OPXT where
  encodeJson = defer \_ -> E.encode E.enum

instance DecodeJson OPXT where
  decodeJson = defer \_ -> D.decode D.enum

derive instance Generic OPXT _

instance Enum OPXT where
  succ = genericSucc
  pred = genericPred

instance Bounded OPXT where
  bottom = genericBottom
  top = genericTop

--------------------------------------------------------------------------------

_OPXT_E :: Prism' OPXT Unit
_OPXT_E = prism' (const OPXT_E) case _ of
  OPXT_E -> Just unit
  _ -> Nothing

_OPXT_B :: Prism' OPXT Unit
_OPXT_B = prism' (const OPXT_B) case _ of
  OPXT_B -> Just unit
  _ -> Nothing

_OPXT_A :: Prism' OPXT Unit
_OPXT_A = prism' (const OPXT_A) case _ of
  OPXT_A -> Just unit
  _ -> Nothing

--------------------------------------------------------------------------------

data PPEF
  = PPEF_N
  | PPEF_A
  | PPEF_M

derive instance Eq PPEF

derive instance Ord PPEF

instance Show PPEF where
  show a = genericShow a

instance EncodeJson PPEF where
  encodeJson = defer \_ -> E.encode E.enum

instance DecodeJson PPEF where
  decodeJson = defer \_ -> D.decode D.enum

derive instance Generic PPEF _

instance Enum PPEF where
  succ = genericSucc
  pred = genericPred

instance Bounded PPEF where
  bottom = genericBottom
  top = genericTop

--------------------------------------------------------------------------------

_PPEF_N :: Prism' PPEF Unit
_PPEF_N = prism' (const PPEF_N) case _ of
  PPEF_N -> Just unit
  _ -> Nothing

_PPEF_A :: Prism' PPEF Unit
_PPEF_A = prism' (const PPEF_A) case _ of
  PPEF_A -> Just unit
  _ -> Nothing

_PPEF_M :: Prism' PPEF Unit
_PPEF_M = prism' (const PPEF_M) case _ of
  PPEF_M -> Just unit
  _ -> Nothing

--------------------------------------------------------------------------------

data PRF
  = PRF_PF
  | PRF_DL
  | PRF_DQ
  | PRF_DF

derive instance Eq PRF

derive instance Ord PRF

instance Show PRF where
  show a = genericShow a

instance EncodeJson PRF where
  encodeJson = defer \_ -> E.encode E.enum

instance DecodeJson PRF where
  decodeJson = defer \_ -> D.decode D.enum

derive instance Generic PRF _

instance Enum PRF where
  succ = genericSucc
  pred = genericPred

instance Bounded PRF where
  bottom = genericBottom
  top = genericTop

--------------------------------------------------------------------------------

_PRF_PF :: Prism' PRF Unit
_PRF_PF = prism' (const PRF_PF) case _ of
  PRF_PF -> Just unit
  _ -> Nothing

_PRF_DL :: Prism' PRF Unit
_PRF_DL = prism' (const PRF_DL) case _ of
  PRF_DL -> Just unit
  _ -> Nothing

_PRF_DQ :: Prism' PRF Unit
_PRF_DQ = prism' (const PRF_DQ) case _ of
  PRF_DQ -> Just unit
  _ -> Nothing

_PRF_DF :: Prism' PRF Unit
_PRF_DF = prism' (const PRF_DF) case _ of
  PRF_DF -> Just unit
  _ -> Nothing

--------------------------------------------------------------------------------

data PYTP
  = PYTP_A
  | PYTP_N
  | PYTP_I
  | PYTP_O

derive instance Eq PYTP

derive instance Ord PYTP

instance Show PYTP where
  show a = genericShow a

instance EncodeJson PYTP where
  encodeJson = defer \_ -> E.encode E.enum

instance DecodeJson PYTP where
  decodeJson = defer \_ -> D.decode D.enum

derive instance Generic PYTP _

instance Enum PYTP where
  succ = genericSucc
  pred = genericPred

instance Bounded PYTP where
  bottom = genericBottom
  top = genericTop

--------------------------------------------------------------------------------

_PYTP_A :: Prism' PYTP Unit
_PYTP_A = prism' (const PYTP_A) case _ of
  PYTP_A -> Just unit
  _ -> Nothing

_PYTP_N :: Prism' PYTP Unit
_PYTP_N = prism' (const PYTP_N) case _ of
  PYTP_N -> Just unit
  _ -> Nothing

_PYTP_I :: Prism' PYTP Unit
_PYTP_I = prism' (const PYTP_I) case _ of
  PYTP_I -> Just unit
  _ -> Nothing

_PYTP_O :: Prism' PYTP Unit
_PYTP_O = prism' (const PYTP_O) case _ of
  PYTP_O -> Just unit
  _ -> Nothing

--------------------------------------------------------------------------------

data Period
  = P_D
  | P_W
  | P_M
  | P_Q
  | P_H
  | P_Y

derive instance Eq Period

derive instance Ord Period

instance Show Period where
  show a = genericShow a

instance EncodeJson Period where
  encodeJson = defer \_ -> E.encode E.enum

instance DecodeJson Period where
  decodeJson = defer \_ -> D.decode D.enum

derive instance Generic Period _

instance Enum Period where
  succ = genericSucc
  pred = genericPred

instance Bounded Period where
  bottom = genericBottom
  top = genericTop

--------------------------------------------------------------------------------

_P_D :: Prism' Period Unit
_P_D = prism' (const P_D) case _ of
  P_D -> Just unit
  _ -> Nothing

_P_W :: Prism' Period Unit
_P_W = prism' (const P_W) case _ of
  P_W -> Just unit
  _ -> Nothing

_P_M :: Prism' Period Unit
_P_M = prism' (const P_M) case _ of
  P_M -> Just unit
  _ -> Nothing

_P_Q :: Prism' Period Unit
_P_Q = prism' (const P_Q) case _ of
  P_Q -> Just unit
  _ -> Nothing

_P_H :: Prism' Period Unit
_P_H = prism' (const P_H) case _ of
  P_H -> Just unit
  _ -> Nothing

_P_Y :: Prism' Period Unit
_P_Y = prism' (const P_Y) case _ of
  P_Y -> Just unit
  _ -> Nothing

--------------------------------------------------------------------------------

data Reference a
  = ReferenceTerms (ContractTermsPoly a)
  | ReferenceId Identifier

instance (EncodeJson a) => EncodeJson (Reference a) where
  encodeJson = defer \_ -> case _ of
    ReferenceTerms a -> E.encodeTagged "ReferenceTerms" a E.value
    ReferenceId a -> E.encodeTagged "ReferenceId" a E.value

instance (DecodeJson a) => DecodeJson (Reference a) where
  decodeJson = defer \_ -> D.decode
    $ D.sumType "Reference"
    $ Map.fromFoldable
        [ "ReferenceTerms" /\ D.content (ReferenceTerms <$> D.value)
        , "ReferenceId" /\ D.content (ReferenceId <$> D.value)
        ]

derive instance Generic (Reference a) _

--------------------------------------------------------------------------------

_ReferenceTerms :: forall a. Prism' (Reference a) (ContractTermsPoly a)
_ReferenceTerms = prism' ReferenceTerms case _ of
  (ReferenceTerms a) -> Just a
  _ -> Nothing

_ReferenceId :: forall a. Prism' (Reference a) Identifier
_ReferenceId = prism' ReferenceId case _ of
  (ReferenceId a) -> Just a
  _ -> Nothing

--------------------------------------------------------------------------------

data ReferenceRole
  = UDL
  | FIL
  | SEL
  | COVE
  | COVI

derive instance Eq ReferenceRole

derive instance Ord ReferenceRole

instance Show ReferenceRole where
  show a = genericShow a

instance EncodeJson ReferenceRole where
  encodeJson = defer \_ -> E.encode E.enum

instance DecodeJson ReferenceRole where
  decodeJson = defer \_ -> D.decode D.enum

derive instance Generic ReferenceRole _

instance Enum ReferenceRole where
  succ = genericSucc
  pred = genericPred

instance Bounded ReferenceRole where
  bottom = genericBottom
  top = genericTop

--------------------------------------------------------------------------------

_UDL :: Prism' ReferenceRole Unit
_UDL = prism' (const UDL) case _ of
  UDL -> Just unit
  _ -> Nothing

_FIL :: Prism' ReferenceRole Unit
_FIL = prism' (const FIL) case _ of
  FIL -> Just unit
  _ -> Nothing

_SEL :: Prism' ReferenceRole Unit
_SEL = prism' (const SEL) case _ of
  SEL -> Just unit
  _ -> Nothing

_COVE :: Prism' ReferenceRole Unit
_COVE = prism' (const COVE) case _ of
  COVE -> Just unit
  _ -> Nothing

_COVI :: Prism' ReferenceRole Unit
_COVI = prism' (const COVI) case _ of
  COVI -> Just unit
  _ -> Nothing

--------------------------------------------------------------------------------

data ReferenceType
  = CNT
  | CID
  | MOC
  | EID
  | CST

derive instance Eq ReferenceType

derive instance Ord ReferenceType

instance Show ReferenceType where
  show a = genericShow a

instance EncodeJson ReferenceType where
  encodeJson = defer \_ -> E.encode E.enum

instance DecodeJson ReferenceType where
  decodeJson = defer \_ -> D.decode D.enum

derive instance Generic ReferenceType _

instance Enum ReferenceType where
  succ = genericSucc
  pred = genericPred

instance Bounded ReferenceType where
  bottom = genericBottom
  top = genericTop

--------------------------------------------------------------------------------

_CNT :: Prism' ReferenceType Unit
_CNT = prism' (const CNT) case _ of
  CNT -> Just unit
  _ -> Nothing

_CID :: Prism' ReferenceType Unit
_CID = prism' (const CID) case _ of
  CID -> Just unit
  _ -> Nothing

_MOC :: Prism' ReferenceType Unit
_MOC = prism' (const MOC) case _ of
  MOC -> Just unit
  _ -> Nothing

_EID :: Prism' ReferenceType Unit
_EID = prism' (const EID) case _ of
  EID -> Just unit
  _ -> Nothing

_CST :: Prism' ReferenceType Unit
_CST = prism' (const CST) case _ of
  CST -> Just unit
  _ -> Nothing

--------------------------------------------------------------------------------

data SCEF
  = SE_OOO
  | SE_IOO
  | SE_ONO
  | SE_OOM
  | SE_INO
  | SE_ONM
  | SE_IOM
  | SE_INM

derive instance Eq SCEF

derive instance Ord SCEF

instance Show SCEF where
  show a = genericShow a

instance EncodeJson SCEF where
  encodeJson = defer \_ -> E.encode E.enum

instance DecodeJson SCEF where
  decodeJson = defer \_ -> D.decode D.enum

derive instance Generic SCEF _

instance Enum SCEF where
  succ = genericSucc
  pred = genericPred

instance Bounded SCEF where
  bottom = genericBottom
  top = genericTop

--------------------------------------------------------------------------------

_SE_OOO :: Prism' SCEF Unit
_SE_OOO = prism' (const SE_OOO) case _ of
  SE_OOO -> Just unit
  _ -> Nothing

_SE_IOO :: Prism' SCEF Unit
_SE_IOO = prism' (const SE_IOO) case _ of
  SE_IOO -> Just unit
  _ -> Nothing

_SE_ONO :: Prism' SCEF Unit
_SE_ONO = prism' (const SE_ONO) case _ of
  SE_ONO -> Just unit
  _ -> Nothing

_SE_OOM :: Prism' SCEF Unit
_SE_OOM = prism' (const SE_OOM) case _ of
  SE_OOM -> Just unit
  _ -> Nothing

_SE_INO :: Prism' SCEF Unit
_SE_INO = prism' (const SE_INO) case _ of
  SE_INO -> Just unit
  _ -> Nothing

_SE_ONM :: Prism' SCEF Unit
_SE_ONM = prism' (const SE_ONM) case _ of
  SE_ONM -> Just unit
  _ -> Nothing

_SE_IOM :: Prism' SCEF Unit
_SE_IOM = prism' (const SE_IOM) case _ of
  SE_IOM -> Just unit
  _ -> Nothing

_SE_INM :: Prism' SCEF Unit
_SE_INM = prism' (const SE_INM) case _ of
  SE_INM -> Just unit
  _ -> Nothing

--------------------------------------------------------------------------------

newtype ScheduleConfig = ScheduleConfig
  { calendar :: Maybe Calendar
  , endOfMonthConvention :: Maybe EOMC
  , businessDayConvention :: Maybe BDC
  }

instance EncodeJson ScheduleConfig where
  encodeJson = defer \_ -> E.encode $ unwrap >$<
    ( E.record
        { calendar: (E.maybe E.value) :: _ (Maybe Calendar)
        , endOfMonthConvention: (E.maybe E.value) :: _ (Maybe EOMC)
        , businessDayConvention: (E.maybe E.value) :: _ (Maybe BDC)
        }
    )

instance DecodeJson ScheduleConfig where
  decodeJson = defer \_ -> D.decode $
    ( ScheduleConfig <$> D.record "ScheduleConfig"
        { calendar: (D.maybe D.value) :: _ (Maybe Calendar)
        , endOfMonthConvention: (D.maybe D.value) :: _ (Maybe EOMC)
        , businessDayConvention: (D.maybe D.value) :: _ (Maybe BDC)
        }
    )

derive instance Generic ScheduleConfig _

derive instance Newtype ScheduleConfig _

--------------------------------------------------------------------------------

_ScheduleConfig :: Iso' ScheduleConfig
  { calendar :: Maybe Calendar
  , endOfMonthConvention :: Maybe EOMC
  , businessDayConvention :: Maybe BDC
  }
_ScheduleConfig = _Newtype

--------------------------------------------------------------------------------

data Stub
  = ShortStub
  | LongStub

derive instance Eq Stub

derive instance Ord Stub

instance Show Stub where
  show a = genericShow a

instance EncodeJson Stub where
  encodeJson = defer \_ -> E.encode E.enum

instance DecodeJson Stub where
  decodeJson = defer \_ -> D.decode D.enum

derive instance Generic Stub _

instance Enum Stub where
  succ = genericSucc
  pred = genericPred

instance Bounded Stub where
  bottom = genericBottom
  top = genericTop

--------------------------------------------------------------------------------

_ShortStub :: Prism' Stub Unit
_ShortStub = prism' (const ShortStub) case _ of
  ShortStub -> Just unit
  _ -> Nothing

_LongStub :: Prism' Stub Unit
_LongStub = prism' (const LongStub) case _ of
  LongStub -> Just unit
  _ -> Nothing
